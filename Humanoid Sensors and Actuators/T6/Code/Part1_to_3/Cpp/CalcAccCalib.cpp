/*********************************************************************
* Compiler:         QT Creator V2.4.1
*                   QT V 4.8.0 (64 bit)
*
* Company:          Institute for Cognitive Systems
*                   Technical University of Munich
*
* Author:           Florian Bergner
*
* Compatibility:
*
* Software Version: V1.0
*
* Created:          05.05.2014
* Changed:          05.05.2014
*
* Comment:
*
*
********************************************************************/

#include "DataProcessing/CalcAccCalib.h"
#include <QDebug>
#include <iostream>
#include <Eigen/SVD>

CalcAccCalib::CalcAccCalib(QObject* parent) : QObject(parent)
{
    m_ax.reserve(1000);
    m_ay.reserve(1000);
    m_az.reserve(1000);

    m_started = false;
}

CalcAccCalib::~CalcAccCalib()
{

}


void CalcAccCalib::calc()
{
    int n = m_ax.size();

    qDebug("n = %d", n);

    if(n==0)
    {
        return;
    }

    const VectorXd x = Map<const VectorXd>(m_ax.constData(),n,1);
    const VectorXd y = Map<const VectorXd>(m_ay.constData(),n,1);
    const VectorXd z = Map<const VectorXd>(m_az.constData(),n,1);

    // ??????????????????????????????????????????????????????????? //
    //      find the A matrix and the center w of ellipsoid
    // ??????????????????????????????????????????????????????????? //

    VectorXd p = calcEllipsoidParameters(x,y,z);
    Vector3d w = calcEllipsoidCenter(p);
    Matrix3d A = calcEllipsoidMatrix(p,w);

    // ??????????????????????????????????????????????????????????? //

    m_A = A;
    m_w = w;

//    Q_EMIT newCalib(m_A,m_w);
}


VectorXd CalcAccCalib::calcEllipsoidParameters(const VectorXd& x,
                                 const VectorXd& y,
                                 const VectorXd& z) const
{
    // ??????????????????????????????????????????????????????????? //
    //      find the 9 parameters p of the ellipsoid equation
    //
    // ??????????????????????????????????????????????????????????? //

    int m = x.rows();
    int n = x.cols();

    int num = std::max(n,m);
    
    MatrixXd m_meas(num, 6);

    VectorXd p = VectorXd::Zero(6);    // ellipsoid parameters
    for (int i=0;i<num;i++){
        m_meas.row(i)<<x(i)*x(i), y(i)*y(i), z(i)*z(i), 2*x(i), 2*y(i), 2*z(i);
    }
    //qDebug("m_meas =\n%s", matrixToString(m_meas).toAscii().data());

    VectorXd d = VectorXd::Ones(num);

    p = CalcAccCalib::solve(m_meas, d);


    qDebug("p =\n%s", matrixToString(p).toAscii().data());

    return p;

    // ??????????????????????????????????????????????????????????? //
}

Vector3d CalcAccCalib::calcEllipsoidCenter(const VectorXd& p) const
{
    // ??????????????????????????????????????????????????????????? //
    //      find the center w of the ellipsoid
    //
    // ??????????????????????????????????????????????????????????? //

    Vector3d w = Vector3d::Zero();
    //qDebug("A =\n%s", w());

    float A = p(0);
    float B = p(1);
    float C = p(2);
    float G = p(3);
    float H = p(4);
    float K = p(5);

    //qDebug("A =\n%s", A);
    Matrix3d A_delta;
    A_delta<< A, 0, 0, 0, B, 0, 0, 0, C;
    Vector3d b_delta;
    b_delta<< 2*G, 2*H, 2*K;

    w = CalcAccCalib::solve((-2*A_delta), b_delta);

    // ??????????????????????????????????????????????????????????? //

    qDebug("w =\n%s", matrixToString(w).toAscii().data());
    return w;
}

Matrix3d CalcAccCalib::calcEllipsoidMatrix(const VectorXd& p, const Vector3d w) const
{
    // ??????????????????????????????????????????????????????????? //
    //      find the ellipsoid matrix A
    //
    // ??????????????????????????????????????????????????????????? //


    Matrix3d A_delta;
    A_delta<< p(0), 0, 0, 0, p(1), 0, 0, 0, p(2);

    Vector3d b;
    b<< p(3), p(4), p(5);

    int c=-1;

    Matrix4d A_bar;
    A_bar << A_delta, b, b.transpose(), c;

    Matrix4d T;
    T <<  Matrix3d::Identity(), w, Vector3d::Zero().transpose(), 1;

    Matrix4d A_hat;
    A_hat = T.transpose()*A_bar*T;


    Matrix3d A = Matrix3d::Identity();     // resulting 3x3 matrix for ellipoid

    A << A_hat(0,0),A_hat(0,1),A_hat(0,2),A_hat(1,0),A_hat(1,1),A_hat(1,2),A_hat(2,0),A_hat(2,1),A_hat(2,2);
    A=-A/A_hat(3,3);


    // ??????????????????????????????????????????????????????????? //

    qDebug("A =\n%s", matrixToString(A).toAscii().data());
    return A;
}

Eigen::VectorXd CalcAccCalib::solve(const Eigen::MatrixXd& A,
                                    const Eigen::VectorXd& b) const
{
    int m = A.rows();
    int n = A.cols();

    int pe = std::min(n,m);

    // ??????????????????????????????????????????????????????????? //
    //      solve the linear equation system A*x = b using SVD
    //
    // ??????????????????????????????????????????????????????????? //

    VectorXd p = VectorXd::Zero(pe);
    JacobiSVD<MatrixXd> svd(A,ComputeThinV | ComputeThinU);
    VectorXd Sig = svd.singularValues();
    MatrixXd U = svd.matrixU();
    MatrixXd V = svd.matrixV();

    p = V*Sig.asDiagonal().inverse()*U.transpose()*b;


    // ??????????????????????????????????????????????????????????? //

    return p;
}

QString CalcAccCalib::matrixToString(const Eigen::MatrixXd& m) const
{
    std::ostringstream out;

    out.str("");
    out.clear();
    out << m;

    return QString(out.str().c_str());
}

void CalcAccCalib::start()
{
    if(m_started)
    {
        return;
    }

    m_ax.reserve(1000);
    m_ay.reserve(1000);
    m_az.reserve(1000);

    m_ax.clear();
    m_ay.clear();
    m_az.clear();

    m_started = true;
    Q_EMIT started();
}

void CalcAccCalib::stop()
{
    if(!m_started)
    {
        return;
    }

    m_started = false;

    m_mutex.lock();
    calc();
    m_mutex.unlock();

    Q_EMIT stopped();
    Q_EMIT newCalib(m_A, m_w);
}

void CalcAccCalib::newRawImuData(ImuData d)
{
    if(!m_started)
    {
        return;
    }

    if(!m_mutex.tryLock())
    {
        return;
    }

    m_ax.append(d.ax());
    m_ay.append(d.ay());
    m_az.append(d.az());

    m_mutex.unlock();

}

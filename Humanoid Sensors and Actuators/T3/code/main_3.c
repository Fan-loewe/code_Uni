#ifndef __AVR_ATmega32__
    #include <avr/iom32.h>
    #error "__FILE__ the CPU you selected is not supported."
#else
    #include <avr/io.h>
#endif

#include <util/delay.h>
#include <avr/interrupt.h>
#include <atmega32/uart.h>


uint8_t counter; // Global variable

void ADC_Init(void)
{
    DDRA=0x0;			// Make ADC port as input
    ADCSRA |= (1<<ADEN) | (1<<ADPS0);	// Enable ADC, factor = 2
    ADMUX |= (1<<REFS0) | (1<<ADLAR) ;	// Vref: Avcc, left adjusted for 8 bit
    SFIOR &= ~((1<<ADTS0) | (1<<ADTS1) | (1<<ADTS2)); //free running mode

}

void adc_readBlocking(uint8_t* b,uint8_t ch)
{

    ADMUX=ADMUX|(ch );	// Set input channel to read

    ADCSRA |= (1<<ADSC);		// Start conversion
    while( ! (ADCSRA&(1<<ADSC) ) ); // wait until conversion is done
    *b = (uint8_t)ADCH;		// Read high byte

}


const uint8_t  sine[]= //256 8-bits values sine wave
{
        0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
        0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
        0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xed,0xef,0xf0,0xf2,0xf3,0xf5,
        0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfc,0xfd,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,
        0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfe,0xfd,0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,
        0xf6,0xf5,0xf3,0xf2,0xf0,0xef,0xed,0xec,0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
        0xda,0xd8,0xd5,0xd3,0xd1,0xce,0xcc,0xc9,0xc7,0xc4,0xc1,0xbf,0xbc,0xb9,0xb6,0xb3,
        0xb0,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
        0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,0x67,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
        0x4f,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
        0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,0x15,0x13,0x12,0x10,0x0f,0x0d,0x0c,0x0a,
        0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
        0x09,0x0a,0x0c,0x0d,0x0f,0x10,0x12,0x13,0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
        0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
        0x4f,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
        };

uint8_t a;
uint8_t c;

uint8_t pwm_read_byte(uint8_t* s)
{
    uint8_t b =(uint8_t*)&s;
    return b;


}



int main (void)
{
    cli(); // disable all interrupts


    DDRC  = 0xFF;


    uart_setBaudrateReg(CALC_BAUD_VAL(62500)); // 15
    uart_setFormat();
    uart_enable();



    
    DDRB |= (1<<PB3);
    TCCR0 |= ((1<<WGM01) | (1<<WGM00) |(1<<CS00) | (1<<COM01) );		//timer0 is used for generating PMW signal, prescale should be equal to one
    //TCCR0 &= ~((1<<CS02) | (1<< CS00) | (1<<FOC0) |(1<<COM00) );
    TCNT0 = 0; // init register counter to 0



    TCCR2 |= ( (1<<CS21) ); //| (1<<CS21) | (1<<CS21) );		//timer2 is used for the output compare interrupt, prescale is 64
    //TCCR2 &= ~((1<<CS22) | (1<< CS20) | (1<<FOC2) |(1<<COM20) );
    TIMSK |= (1<<OCIE2);
    //TIMSK |= (1<<TOIE2);//for overflow
    OCR2 = 48;
    TCNT2 = 0; // init register counter to 0
    a=0;
    c=0;
    sei(); // enable interrupts
    //OCR0 =20;
    ADC_Init();

    /*uint16_t i;
    uint8_t val[1024];

    for(i=0;i<1024;i++) { // read in this loop
        adc_readBlocking(&val[i],0); // read from channel 0
    }
    for(i=0;i<4;i++){ // transmit in this loop


        uart_writeBlocking(&val[255*i], 255);
    }
    PORTC=0xFF;*/
    while(1){



    adc_readBlocking(&c,0); // read from channel 0 into

        uart_writeBlocking((uint8_t*)&c,1); // transmit var a over serial connection

    }

    return 0;
}

// The sinewave table must be entirely browsed F times per second, where F is the desired sine frequency.
// We therefore need to know exactly the time between two jumps in the sinewave table.
// To that end we use the TIMER COMPARE Interrupt, generated when a timer reaches a value defined in OCRxx


ISR(TIMER2_COMP_vect) // Interrupt service routine for TIMERXX COMPARE Interrupt
{
    if(a<256){
        //PORTC=0xFF;
        //OCR0=pwm_read_byte(&sine[a]);
        OCR0=sine[a];
        a=a+7;// change to 7 (found 6.55) to have a 100 Hz frequency
    }else{
        a=0;

    }

TCNT2 = 0;
}
